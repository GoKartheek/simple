{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _Object$values from \"@babel/runtime-corejs2/core-js/object/values\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { format as formatUrl, parse as parseUrl } from 'url'; // import { Config } from '../../types'\n\nimport { removeSubpath, subpathIsPresent } from './index';\nimport subpathIsRequired from './subpath-is-required';\nimport subpathFromLng from './subpath-from-lng';\n\nconst parseAs = (originalAs, href) => {\n  const asType = typeof originalAs;\n  let as;\n\n  if (asType === 'undefined') {\n    as = formatUrl(href, {\n      unicode: true\n    });\n  } else if (asType === 'string') {\n    as = originalAs;\n  } else {\n    throw new Error(`'as' type must be 'string', but it is ${asType}`);\n  }\n\n  return as;\n};\n\nconst parseHref = originalHref => {\n  const hrefType = typeof originalHref;\n  let href;\n\n  if (hrefType === 'string') {\n    href = parseUrl(originalHref, true\n    /* parseQueryString */\n    );\n  } else if (hrefType === 'object') {\n    href = _objectSpread({}, originalHref);\n    href.query = originalHref.query ? _objectSpread({}, originalHref.query) : {};\n  } else {\n    throw new Error(`'href' type must be either 'string' or 'object', but it is ${hrefType}`);\n  }\n\n  return href;\n};\n\nexport default ((config, currentRoute, currentLanguage) => {\n  const {\n    allLanguages,\n    localeSubpaths\n  } = config;\n  const {\n    as: originalAs,\n    href: originalHref\n  } = currentRoute;\n\n  if (!allLanguages.includes(currentLanguage)) {\n    throw new Error('Invalid configuration: Current language is not included in all languages array');\n  }\n\n  let href = parseHref(originalHref);\n  let as = parseAs(originalAs, href);\n  /*\n    url.format prefers the 'url.search' string over\n    the 'url.query' object, so remove the search\n    string to ensure the query object is used.\n  */\n\n  delete href.search;\n  /*\n    Strip any/all subpaths from the `as` value\n  */\n\n  _Object$values(localeSubpaths).forEach(subpath => {\n    if (subpathIsPresent(as, subpath)) {\n      as = removeSubpath(as, subpath);\n    }\n  });\n\n  if (subpathIsRequired(config, currentLanguage)) {\n    const basePath = `${href.protocol}//${href.host}`;\n    const currentAs = as.replace(basePath, '');\n    const subpath = subpathFromLng(config, currentLanguage);\n    as = `/${currentAs}/${subpath}`.replace(/\\/$/, '');\n    href.query.lng = currentLanguage;\n    href.query.subpath = subpath;\n  }\n\n  return {\n    as,\n    href\n  };\n});","map":{"version":3,"sources":["/Users/kartheek/Desktop/zenrays/next/lang/simple/utils/lng-path-corrector.js"],"names":["format","formatUrl","parse","parseUrl","removeSubpath","subpathIsPresent","subpathIsRequired","subpathFromLng","parseAs","originalAs","href","asType","as","unicode","Error","parseHref","originalHref","hrefType","query","config","currentRoute","currentLanguage","allLanguages","localeSubpaths","includes","search","forEach","subpath","basePath","protocol","host","currentAs","replace","lng"],"mappings":"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","sourcesContent":["import { format as formatUrl, parse as parseUrl } from 'url'\n\n// import { Config } from '../../types'\nimport { removeSubpath, subpathIsPresent } from './index'\nimport subpathIsRequired from './subpath-is-required'\nimport subpathFromLng from './subpath-from-lng'\n\nconst parseAs = (originalAs, href) => {\n  const asType = typeof originalAs\n  let as\n\n  if (asType === 'undefined') {\n    as = formatUrl(href, { unicode: true })\n  } else if (asType === 'string') {\n    as = originalAs\n  } else {\n    throw new Error(`'as' type must be 'string', but it is ${asType}`)\n  }\n\n  return as\n}\n\nconst parseHref = (originalHref) => {\n  const hrefType = typeof originalHref\n  let href\n\n  if (hrefType === 'string') {\n    href = parseUrl(originalHref, true /* parseQueryString */)\n  } else if (hrefType === 'object') {\n    href = { ...originalHref }\n    href.query = originalHref.query ? { ...originalHref.query } : {}\n  } else {\n    throw new Error(`'href' type must be either 'string' or 'object', but it is ${hrefType}`)\n  }\n\n  return href\n}\n\nexport default (config, currentRoute, currentLanguage) => {\n  const { allLanguages, localeSubpaths } = config\n  const { as: originalAs, href: originalHref } = currentRoute\n\n  if (!allLanguages.includes(currentLanguage)) {\n    throw new Error('Invalid configuration: Current language is not included in all languages array')\n  }\n\n  let href = parseHref(originalHref)\n  let as = parseAs(originalAs, href)\n\n  /*\n    url.format prefers the 'url.search' string over\n    the 'url.query' object, so remove the search\n    string to ensure the query object is used.\n  */\n  delete href.search\n\n  /*\n    Strip any/all subpaths from the `as` value\n  */\n  Object.values(localeSubpaths).forEach((subpath) => {\n    if (subpathIsPresent(as, subpath)) {\n      as = removeSubpath(as, subpath)\n    }\n  })\n\n  if (subpathIsRequired(config, currentLanguage)) {\n    const basePath = `${href.protocol}//${href.host}`\n    const currentAs = as.replace(basePath, '')\n    const subpath = subpathFromLng(config, currentLanguage)\n\n    as = `/${currentAs}/${subpath}`.replace(/\\/$/, '')\n    href.query.lng = currentLanguage\n    href.query.subpath = subpath\n  }\n\n  return { as, href }\n}"]},"metadata":{},"sourceType":"module"}